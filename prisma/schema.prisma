// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// --- ENUMS ---

enum UserRole {
  CLIENT
  PROVIDER
  COMPANY
  EMPLOYEE
  ADMIN
}

enum ProviderType {
  FREELANCER
  COMPANY
}

enum ProviderOnboardingStatus {
  PENDING
  APPROVED
  REJECTED
}

enum BookingMode {
  MANUAL
  SMART_MATCH
}

enum CleaningFrequency {
  ONCE
  WEEKLY
  BIWEEKLY
  MONTHLY
  CONTRACT
}

enum EcoPreference {
  STANDARD
  BIO
}

enum SoilLevel {
  LIGHT
  NORMAL
  STRONG
  EXTREME
}

enum BookingStatus {
  DRAFT
  PENDING_PROVIDER
  PENDING_CLIENT
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  DISPUTED
}

enum PaymentStatus {
  PENDING
  REQUIRES_ACTION
  AUTHORIZED
  CAPTURE_PENDING
  CAPTURED
  HELD
  RELEASED
  REFUNDED
  FAILED
  DISPUTED
}

enum PayoutBatchStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum ProviderPayoutStatus {
  PENDING
  PROCESSING
  PAID
  FAILED
}

enum PayoutBatchTrigger {
  AUTO
  MANUAL
}

enum PaymentMethod {
  CARD
  SEPA
  PAYPAL
}

enum PaymentProvider {
  MOLLIE
  ADYEN
  OTHER
}

enum WebhookDeliveryStatus {
  RECEIVED
  PROCESSING
  PROCESSED
  FAILED
  IGNORED
}

enum SystemApiKeyStatus {
  ACTIVE
  PAUSED
  REVOKED
}

enum DataJobFormat {
  CSV
  JSON
}

enum DataJobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum DataImportEntity {
  USERS
  PROVIDERS
  BOOKINGS
  PAYMENTS
  ZONES
  SERVICES
  OTHER
}

enum DataExportType {
  BOOKINGS
  PAYMENTS
  PROVIDERS
  CLIENTS
  DISPUTES
  FINANCE
  OTHER
}

enum EmailQueueStatus {
  PENDING
  SENT
  FAILED
}

enum DocumentType {
  IDENTITY
  INSURANCE
  TAX
  CONTRACT
  CHECKLIST
  PHOTO_BEFORE
  PHOTO_AFTER
  INVOICE
  PROFILE_PHOTO
  OTHER
}

enum DocumentReviewStatus {
  PENDING
  UNDER_REVIEW
  APPROVED
  REJECTED
}

enum IdentityVerificationStatus {
  NOT_STARTED
  SUBMITTED
  VERIFIED
  REJECTED
}

enum AdminReviewTarget {
  DOCUMENT
  PROVIDER_PROFILE
  BOOKING
  PAYMENT
}

enum AdminReviewStatus {
  PENDING
  APPROVED
  REJECTED
}

enum ReviewStatus {
  PUBLISHED
  HIDDEN
  FLAGGED
}

enum DisputeStatus {
  OPEN
  UNDER_REVIEW
  ACTION_REQUIRED
  REFUNDED
  RESOLVED
  REJECTED
}

enum DisputeParticipantRole {
  CLIENT
  PROVIDER
  ADMIN
}

enum PricingRuleType {
  BASE_RATE
  ECO_SURCHARGE
  LOYALTY_EARN
  LOYALTY_REDEEM
}

enum PricingRuleAudience {
  GENERAL
  BUSINESS
}

enum LoyaltyTransactionType {
  EARN
  REDEEM
  ADJUST
}

enum PromoCodeType {
  FIXED
  PERCENT
}

enum MarketingLandingStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

/// --- MODELS ---

/// --- MODELS ---

model User {
  id              String     @id @default(cuid())
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  email           String     @unique
  hashedPassword  String?
  phone           String?
  firstName       String
  lastName        String
  preferredLocale String     @default("de")
  isActive        Boolean    @default(true)
  roles           UserRole[]

  providerProfile         ProviderProfile?
  clientProfile           ClientProfile?
  employeeProfiles        EmployeeProfile[]
  companiesOwned          Company[]               @relation("CompanyOwners")
  companyMemberships      CompanyMember[]
  bookings                Booking[]               @relation("BookingClient")
  reviews                 Review[]                @relation("ReviewAuthor")
  payments                Payment[]               @relation("PaymentClient")
  documentsUploaded       Document[]              @relation("UserDocuments")
  bookingAuditEntries     BookingAudit[]          @relation("UserBookingAudits")
  supportTicketsRequested SupportTicket[]         @relation("TicketRequester")
  supportTicketsAssigned  SupportTicket[]         @relation("TicketAssignee")
  supportMessages         SupportMessage[]        @relation("UserSupportMessages")
  notifications           Notification[]
  notificationPreference  NotificationPreference? @relation("UserNotificationPreference")
  profileAudits           UserProfileAudit[]
  refreshTokens           RefreshToken[]
  preference              UserPreference?
  paymentMandates         PaymentMandate[]
  loyaltyBalance          LoyaltyBalance?
  documentReviews         Document[]              @relation("DocumentReviewer")
  adminReviews            AdminReview[]
  disputesOpened          Dispute[]               @relation("DisputeOpenedBy")
  disputesAssigned        Dispute[]               @relation("DisputeAssigned")
  disputeMessages         DisputeMessage[]        @relation("UserDisputeMessages")
  promoCodesCreated       PromoCode[]             @relation("PromoCodeCreator")
  promoCodeUsages         PromoCodeUsage[]        @relation("PromoCodeUsageClient")
  reviewsModerated        Review[]                @relation("ReviewModeratedBy")
  marketingSettingsUpdated MarketingSetting[]     @relation("MarketingSettingUpdatedBy")
  marketingSettingLogs    MarketingSettingLog[]
  gdprRequests            GdprRequest[]
  gdprRequestsStarted     GdprRequest[]           @relation("GdprRequestStartedBy")
  gdprRequestsProcessed   GdprRequest[]           @relation("GdprRequestProcessedBy")
  gdprRequestsRejected    GdprRequest[]           @relation("GdprRequestRejectedBy")
  consent                 UserConsent?
  consentHistory          UserConsentHistory[]    @relation("UserConsentSubject")
  consentHistoryActor     UserConsentHistory[]    @relation("UserConsentActor")
  loginAttempts           LoginAttempt[]
  identityVerificationReviews ProviderProfile[] @relation("IdentityVerificationReviewer")
  securityIncidentsAssigned SecurityIncident[] @relation("SecurityIncidentAssigned")
  securityIncidentsResolved SecurityIncident[] @relation("SecurityIncidentResolvedBy")
  securityIncidentTimelineEntries SecurityIncidentTimeline[] @relation("SecurityIncidentTimelineActor")
  identityAuditLogs       IdentityAuditLog[]      @relation("IdentityAuditActor")
  gdprRequestAuditEntries GdprRequestAudit[]      @relation("GdprRequestAuditActor")
  webhookEvents           WebhookEventLog[]       @relation("UserWebhookEvents")
  apiKeysOwned            SystemApiKey[]          @relation("UserApiKeys")
  dataImportsCreated      DataImportJob[]         @relation("DataImportJobCreatedBy")
  dataExportsRequested    DataExportJob[]         @relation("DataExportJobRequestedBy")
}

model ProviderProfile {
  id                String       @id @default(cuid())
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt
  user              User         @relation(fields: [userId], references: [id])
  userId            String       @unique
  providerType      ProviderType
  languages         String[]     @default([])
  serviceAreas      String[]     @default([])
  serviceZones      ProviderServiceZone[]
  availabilitySlots ProviderAvailabilitySlot[]
  timeOffPeriods    ProviderTimeOff[]
  serviceCategories String[]     @default([])
  hourlyRateCents   Int
  offersEco         Boolean      @default(false)
  bio               String?
  yearsExperience   Int?
  ratingAverage     Float?       @default(0)
  ratingCount       Int?         @default(0)
  payoutMethod      String?
  payoutLast4       String?
  payoutReady       Boolean      @default(false)
  kycStatus         String?      @default("pending")
  payoutActivationStatus String  @default("pending")
  payoutAccountHolder String?
  payoutIbanMasked  String?
  payoutIbanCountry String?
  payoutBankName    String?
  payoutMollieCustomerId String?
  payoutMollieMandateId  String?
  acceptsAnimals    Boolean      @default(false)
  gender            String?
  birthDate         DateTime?
  birthCity         String?
  birthCountry      String?
  nationality       String?
  termsAcceptedAt   DateTime?
  addressStreetLine1 String?
  addressStreetLine2 String?
  addressPostalCode String?
  addressCity       String?
  addressRegion     String?
  onboardingStatus  String       @default("account_created")
  identityCompletedAt DateTime?
  addressCompletedAt DateTime?
  profileCompletedAt DateTime?
  pricingCompletedAt DateTime?
  phoneVerifiedAt   DateTime?
  pendingPhoneNumber String?
  phoneVerificationCode String?
  phoneVerificationExpiresAt DateTime?
  identityVerifiedAt DateTime?
  identityVerificationStatus IdentityVerificationStatus @default(NOT_STARTED)
  identityVerificationReviewer String?
  identityVerificationReviewerUser User? @relation("IdentityVerificationReviewer", fields: [identityVerificationReviewerId], references: [id])
  identityVerificationReviewerId String?
  identityVerificationReviewedAt DateTime?
  identityVerificationNotes String?
  onfidoApplicantId String?
  onfidoWorkflowRunId String?
  onfidoCheckId String?
  onfidoReportIds String[] @default([])
  signupFeePaidAt DateTime?
  welcomeSessionCompletedAt DateTime?

  documents Document[]          @relation("ProviderDocuments")
  bookings  BookingAssignment[]
  reviews   Review[]            @relation("ProviderReviews")
  payouts   ProviderPayout[]
  teamsOwned ProviderTeam[]     @relation("ProviderTeamOwner")
  teamMemberships ProviderTeamMember[]
  bookingLocks BookingTeamLock[]
  invitations BookingInvitation[]
  notifications Notification[]  @relation("ProviderNotification")
  identityAuditLogs IdentityAuditLog[] @relation("ProviderIdentityAuditLogs")
  webhookEvents   WebhookEventLog[]    @relation("ProviderWebhookEvents")
}

model PayoutBatch {
  id             String          @id @default(cuid())
  createdAt      DateTime        @default(now())
  scheduledFor   DateTime
  status         PayoutBatchStatus @default(PENDING)
  trigger        PayoutBatchTrigger @default(AUTO)
  note           String?

  payouts        ProviderPayout[]
}

model ProviderPayout {
  id             String   @id @default(cuid())
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  batch          PayoutBatch @relation(fields: [batchId], references: [id])
  batchId        String
  provider       ProviderProfile @relation(fields: [providerId], references: [id])
  providerId     String
  amountCents    Int
  currency       String  @default("EUR")
  status         ProviderPayoutStatus @default(PENDING)
  externalReference String?
  availableOn    DateTime?
  releasedAt     DateTime?
  missions       Json

  documents      Document[]
  distributions  PaymentDistribution[]
}

model ProviderOnboardingRequest {
  id           String                    @id @default(cuid())
  createdAt    DateTime                  @default(now())
  updatedAt    DateTime                  @updatedAt
  type         ProviderType
  contactName  String
  companyName  String?
  email        String
  phone        String?
  languages    String[]
  serviceAreas String[]
  message      String?
  status       ProviderOnboardingStatus @default(PENDING)
  reviewer     String?
  reviewedAt   DateTime?
}

model Company {
  id           String   @id @default(cuid())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  name         String
  vatNumber    String?
  legalForm    String?
  billingEmail String
  phone        String?
  streetLine1  String
  streetLine2  String?
  postalCode   String
  city         String
  countryCode  String
  locales      String[] @default(["de"])
  ecoPolicy    String?
  owner        User?    @relation("CompanyOwners", fields: [ownerId], references: [id])
  ownerId      String?

  members          CompanyMember[]
  bookings         Booking[]         @relation("BookingCompany")
  employeeProfiles EmployeeProfile[]
}

model CompanyMember {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  company     Company  @relation(fields: [companyId], references: [id])
  companyId   String
  user        User     @relation(fields: [userId], references: [id])
  userId      String
  role        String
  permissions String[] @default([])

  @@unique([companyId, userId])
}

model EmployeeProfile {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  company     Company  @relation(fields: [companyId], references: [id])
  companyId   String
  user        User     @relation(fields: [userId], references: [id])
  userId      String
  role        String
  permissions String[] @default([])
}

model ClientProfile {
  id                 String   @id @default(cuid())
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  user               User     @relation(fields: [userId], references: [id])
  userId             String   @unique
  defaultLocale      String   @default("de")
  favouriteProviders String[] @default([])
  loyaltyPoints      Int      @default(0)
  externalCustomerId String?  @unique
  defaultPaymentMethodId String?

  addresses ClientAddress[]
}

model ClientAddress {
  id          String        @id @default(cuid())
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  profile     ClientProfile @relation(fields: [profileId], references: [id])
  profileId   String
  label       String
  streetLine1 String
  streetLine2 String?
  postalCode  String
  city        String
  countryCode String
  accessNotes String?
  latitude    Float?
  longitude   Float?
}

model SupportTicket {
  id          String              @id @default(cuid())
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  status      SupportStatus       @default(OPEN)
  priority    SupportPriority     @default(MEDIUM)
  category    SupportCategory     @default(OTHER)
  subject     String
  description String
  booking     Booking?            @relation(fields: [bookingId], references: [id])
  bookingId   String?
  requester   User                @relation("TicketRequester", fields: [requesterId], references: [id])
  requesterId String
  assignee    User?               @relation("TicketAssignee", fields: [assigneeId], references: [id])
  assigneeId  String?
  dueAt       DateTime?
  messages    SupportMessage[]
  attachments SupportAttachment[]
}

model SupportMessage {
  id          String              @id @default(cuid())
  createdAt   DateTime            @default(now())
  content     String
  internal    Boolean             @default(false)
  ticket      SupportTicket       @relation(fields: [ticketId], references: [id])
  ticketId    String
  author      User                @relation("UserSupportMessages", fields: [authorId], references: [id])
  authorId    String
  attachments SupportAttachment[]
}

model SupportAttachment {
  id              String         @id @default(cuid())
  createdAt       DateTime       @default(now())
  url             String
  filename        String
  message         SupportMessage @relation(fields: [messageId], references: [id])
  messageId       String
  SupportTicket   SupportTicket? @relation(fields: [supportTicketId], references: [id])
  supportTicketId String?
}

model Notification {
  id              String                        @id @default(cuid())
  createdAt       DateTime                      @default(now())
  readAt          DateTime?
  type            NotificationType
  channel         NotificationChannel           @default(IN_APP)
  deliveryStatus  NotificationDeliveryStatus    @default(PENDING)
  templateKey     String?
  payload         Json
  user            User                          @relation(fields: [userId], references: [id])
  userId          String
  booking         Booking?                      @relation(fields: [bookingId], references: [id])
  bookingId       String?
  provider        ProviderProfile?              @relation("ProviderNotification", fields: [providerId], references: [id])
  providerId      String?
  contextClientId String?
  contextMetadata Json?
  errorCode       String?
  errorMessage    String?
}

model NotificationPreference {
  id         String                @id @default(cuid())
  user       User                  @relation("UserNotificationPreference", fields: [userId], references: [id])
  userId     String                @unique
  channels   NotificationChannel[] @default([IN_APP])
  language   String?
  mutedTypes NotificationType[]
}

model NotificationTemplate {
  id                String                     @id @default(cuid())
  createdAt         DateTime                   @default(now())
  updatedAt         DateTime                   @updatedAt
  key               String                     @unique
  name              String
  description       String?
  status            NotificationTemplateStatus @default(ACTIVE)
  supportedChannels NotificationChannel[]      @default([IN_APP, EMAIL])
  activeChannels    NotificationChannel[]      @default([IN_APP, EMAIL])
  locales           String[]                @default([])
  metadata          Json?
  rules             NotificationAutomationRule[]
}

model NotificationAutomationRule {
  id           String                         @id @default(cuid())
  createdAt    DateTime                       @default(now())
  updatedAt    DateTime                       @updatedAt
  key          String                         @unique
  name         String
  description  String?
  event        NotificationAutomationEvent
  audience     NotificationAutomationAudience @default(CLIENT)
  channels     NotificationChannel[]          @default([IN_APP])
  delaySeconds Int?
  isActive     Boolean                        @default(true)
  conditions   Json?
  template     NotificationTemplate?          @relation(fields: [templateId], references: [id])
  templateId   String?
}

model UserProfileAudit {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  field     String
  oldValue  String?
  newValue  String?
}

enum SupportStatus {
  OPEN
  IN_PROGRESS
  WAITING_CUSTOMER
  RESOLVED
  CLOSED
}

enum SupportPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum SupportCategory {
  ONBOARDING
  BILLING
  INCIDENT
  FEATURE_REQUEST
  OTHER
}

enum NotificationType {
  BOOKING_STATUS
  BOOKING_ASSIGNMENT
  BOOKING_CANCELLATION
  BILLING
  SUPPORT_UPDATE
  MATCHING_PROGRESS
  IDENTITY_VERIFICATION
  COMPLIANCE
}

enum NotificationChannel {
  IN_APP
  EMAIL
  PUSH
}

enum NotificationDeliveryStatus {
  PENDING
  SENT
  DELIVERED
  FAILED
  BOUNCED
}

enum NotificationTemplateStatus {
  ACTIVE
  DISABLED
  ARCHIVED
}

enum NotificationAutomationEvent {
  BOOKING_CREATED
  BOOKING_CONFIRMED
  BOOKING_COMPLETED
  PAYMENT_FAILED
  MATCHING_PROGRESS
  SMART_MATCH_TRIGGERED
}

enum NotificationAutomationAudience {
  CLIENT
  PROVIDER
  ADMIN
}

enum IdentityAuditAction {
  SUBMITTED
  UNDER_REVIEW
  APPROVED
  REJECTED
  RESET
  REQUESTED_DOCUMENT
  NOTE
}

enum GdprRequestType {
  EXPORT
  DELETION
  RECTIFICATION
}

enum GdprRequestStatus {
  PENDING
  PROCESSING
  COMPLETED
  REJECTED
}

enum DigestFrequency {
  NEVER
  DAILY
  WEEKLY
}

enum SecurityIncidentStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum SecurityIncidentCategory {
  AUTH
  PERMISSIONS
  WEBHOOK
  PAYMENT
  ADMIN
  OTHER
}

enum SecurityIncidentSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum SecurityLogCategory {
  AUTH
  PERMISSIONS
  WEBHOOK
  PAYMENT
  ADMIN
  OTHER
}

enum SecurityLogLevel {
  INFO
  WARN
  ERROR
}

model UserPreference {
  id               String           @id @default(cuid())
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  marketingEmails  Boolean          @default(false)
  productUpdates   Boolean          @default(true)
  enableDarkMode   Boolean          @default(false)
  digestFrequency  DigestFrequency  @default(WEEKLY)
  user             User             @relation(fields: [userId], references: [id])
  userId           String           @unique
}

model UserConsent {
  id                 String                @id @default(cuid())
  createdAt          DateTime              @default(now())
  updatedAt          DateTime              @updatedAt
  user               User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId             String                @unique
  consentMarketing   Boolean               @default(false)
  consentStats       Boolean               @default(false)
  consentPreferences Boolean               @default(false)
  consentNecessary   Boolean               @default(true)
  source             String?
  channel            String?
  capturedAt         DateTime?
  firstCapturedAt    DateTime?

  history UserConsentHistory[]
}

model UserConsentHistory {
  id                 String    @id @default(cuid())
  createdAt          DateTime  @default(now())
  consent            UserConsent @relation(fields: [consentId], references: [id], onDelete: Cascade)
  consentId          String
  user               User      @relation("UserConsentSubject", fields: [userId], references: [id], onDelete: Cascade)
  userId             String
  actor              User?     @relation("UserConsentActor", fields: [actorId], references: [id])
  actorId            String?
  actorLabel         String?
  consentMarketing   Boolean
  consentStats       Boolean
  consentPreferences Boolean
  consentNecessary   Boolean
  source             String?
  channel            String?
  ipAddress          String?
  userAgent          String?
  notes              String?
  capturedAt         DateTime?

  @@index([userId])
  @@index([actorId])
}

model LoginAttempt {
  id         String    @id @default(cuid())
  createdAt  DateTime  @default(now())
  email      String
  user       User?     @relation(fields: [userId], references: [id], onDelete: SetNull)
  userId     String?
  userRole   UserRole?
  provider   String?   /// login provider (password, google, apple, etc.)
  success    Boolean
  reason     String?
  ipAddress  String?
  userAgent  String?

  @@index([email])
  @@index([createdAt])
  @@index([userId])
}

model SecurityIncident {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  title       String
  description String
  status      SecurityIncidentStatus @default(OPEN)
  category    SecurityIncidentCategory @default(OTHER)
  severity    SecurityIncidentSeverity @default(MEDIUM)
  assignedTo  User?    @relation("SecurityIncidentAssigned", fields: [assignedToId], references: [id], onDelete: SetNull)
  assignedToId String?
  resolvedAt  DateTime?
  resolvedBy  User?    @relation("SecurityIncidentResolvedBy", fields: [resolvedById], references: [id], onDelete: SetNull)
  resolvedById String?
  timeline    SecurityIncidentTimeline[]
}

model SecurityIncidentTimeline {
  id          String            @id @default(cuid())
  createdAt   DateTime          @default(now())
  incident    SecurityIncident  @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  incidentId  String
  actor       User?             @relation("SecurityIncidentTimelineActor", fields: [actorId], references: [id], onDelete: SetNull)
  actorId     String?
  actorLabel  String?
  action      String
  message     String?
  metadata    Json?
}

model SecurityLog {
  id         String             @id @default(cuid())
  createdAt  DateTime           @default(now())
  category   SecurityLogCategory @default(OTHER)
  level      SecurityLogLevel    @default(INFO)
  message    String
  requestId  String?
  actorId    String?
  actorEmail String?
  metadata   Json?
}

model Document {
  id           String           @id @default(cuid())
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt
  type         DocumentType
  url          String
  name         String?
  metadata     Json?
  uploadedBy   User?            @relation("UserDocuments", fields: [uploadedById], references: [id])
  uploadedById String?
  provider     ProviderProfile? @relation("ProviderDocuments", fields: [providerId], references: [id])
  providerId   String?
  booking      Booking?         @relation("BookingDocuments", fields: [bookingId], references: [id])
  bookingId    String?
  providerPayout ProviderPayout? @relation(fields: [providerPayoutId], references: [id])
  providerPayoutId String?
  invoice      Invoice?
  reviewStatus DocumentReviewStatus @default(PENDING)
  reviewNotes  String?
  reviewedAt   DateTime?
  reviewer     User?            @relation("DocumentReviewer", fields: [reviewerId], references: [id])
  reviewerId   String?
  adminReviews AdminReview[]
  identityAuditLogs IdentityAuditLog[] @relation("DocumentIdentityAuditLogs")
}

model IdentityDocumentType {
  id                 String   @id @default(cuid())
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  code               String   @unique
  labelFr            String
  labelEn            String?
  labelDe            String?
  description        String?
  isRequired         Boolean  @default(true)
  requiredFiles      Int      @default(1)
  applicableCountries String[] @default([])
  isActive           Boolean  @default(true)
  archivedAt         DateTime?
  metadata           Json?
}

model IdentityAuditLog {
  id         String              @id @default(cuid())
  createdAt  DateTime            @default(now())
  provider   ProviderProfile     @relation("ProviderIdentityAuditLogs", fields: [providerId], references: [id])
  providerId String
  document   Document?           @relation("DocumentIdentityAuditLogs", fields: [documentId], references: [id])
  documentId String?
  actor      User?               @relation("IdentityAuditActor", fields: [actorId], references: [id])
  actorId    String?
  actorLabel String?
  action     IdentityAuditAction
  payload    Json?
}

model GdprRequest {
  id             String            @id @default(cuid())
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  type           GdprRequestType
  status         GdprRequestStatus @default(PENDING)
  user           User              @relation(fields: [userId], references: [id])
  userId         String
  userRole       UserRole
  userEmail      String
  reason         String?
  startedAt      DateTime?
  startedById    String?
  startedBy      User?             @relation("GdprRequestStartedBy", fields: [startedById], references: [id])
  processedAt    DateTime?
  processedById  String?
  processedBy    User?             @relation("GdprRequestProcessedBy", fields: [processedById], references: [id])
  rejectedAt     DateTime?
  rejectedById   String?
  rejectedBy     User?             @relation("GdprRequestRejectedBy", fields: [rejectedById], references: [id])
  rejectReason   String?
  exportPath     String?
  exportReadyAt  DateTime?
  exportExpiresAt DateTime?
  metadata       Json?

  auditLogs      GdprRequestAudit[]
}

model GdprRequestAudit {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now())
  request    GdprRequest @relation(fields: [requestId], references: [id])
  requestId  String
  action     String
  actor      User?    @relation("GdprRequestAuditActor", fields: [actorId], references: [id])
  actorId    String?
  actorLabel String?
  metadata   Json?
}

model AdminReview {
  id         String             @id @default(cuid())
  createdAt  DateTime           @default(now())
  updatedAt  DateTime           @updatedAt
  type       AdminReviewTarget
  status     AdminReviewStatus  @default(PENDING)
  targetId   String
  targetLabel String?
  notes      String?
  metadata   Json?
  reviewer   User?              @relation(fields: [reviewerId], references: [id])
  reviewerId String?
  document   Document?          @relation(fields: [documentId], references: [id])
  documentId String?
}

model Booking {
  id                   String            @id @default(cuid())
  createdAt            DateTime          @default(now())
  updatedAt            DateTime          @updatedAt
  client               User?             @relation("BookingClient", fields: [clientId], references: [id])
  clientId             String?
  company              Company?          @relation("BookingCompany", fields: [companyId], references: [id])
  companyId            String?
  service              String
  surfacesSquareMeters Decimal?          @db.Decimal(10, 2)
  durationHours        Decimal?          @db.Decimal(5, 2)
  recommendedHours     Decimal?          @db.Decimal(5, 2)
  durationManuallyAdjusted Boolean       @default(false)
  startAt              DateTime
  endAt                DateTime
  frequency            CleaningFrequency
  mode                 BookingMode
  ecoPreference        EcoPreference
  couponCode           String?
  promoCode            PromoCode?        @relation(fields: [promoCodeId], references: [id])
  promoCodeId          String?
  contactFirstName     String?
  contactLastName      String?
  contactCompany       String?
  contactPhone         String?
  contactStreetLine1   String?
  contactStreetLine2   String?
  contactPostalCode    String?
  contactCity          String?
  contactCountryCode   String?
  contactAccessNotes   String?
  onsiteContactFirstName String?
  onsiteContactLastName  String?
  onsiteContactPhone     String?
  addressStreetLine1   String
  addressStreetLine2   String?
  addressPostalCode    String
  addressCity          String
  addressCountryCode   String
  addressAccessNotes   String?
  billingStreetLine1   String?
  billingStreetLine2   String?
  billingPostalCode    String?
  billingCity          String?
  billingCountryCode   String?
  billingAccessNotes   String?
  status               BookingStatus     @default(PENDING_PROVIDER)
  pricingSubtotalCents Int
  pricingEcoCents      Int
  pricingLoyaltyCents  Int             @default(0)
  pricingExtrasCents   Int
  pricingTaxCents      Int
  pricingCurrency      String            @default("EUR")
  pricingTotalCents    Int
  notes                String?
  opsNotes             String?
  providerNotes        String?
  reminderAt           DateTime?
  reminderNotes        String?
  requiredProviders    Int               @default(1)
  preferredTeam        ProviderTeam?     @relation("BookingPreferredTeam", fields: [preferredTeamId], references: [id])
  preferredTeamId      String?
  assignedTeam         ProviderTeam?     @relation("BookingAssignedTeam", fields: [assignedTeamId], references: [id])
  assignedTeamId       String?
  matchingRetryCount   Int               @default(0)
  fallbackEscalatedAt  DateTime?
  fallbackRequestedAt  DateTime?
  fallbackTeamCandidate   ProviderTeam? @relation("BookingFallbackTeam", fields: [fallbackTeamCandidateId], references: [id])
  fallbackTeamCandidateId String?

  assignments BookingAssignment[]
  auditLog    BookingAudit[]
  attachments Document[]          @relation("BookingDocuments")
  payments    Payment[]
  reviews     Review[]
  invoices    Invoice[]
  loyaltyTransactions LoyaltyTransaction[]
  bookingLocks BookingTeamLock[]
  disputes    Dispute[]
  invitations BookingInvitation[]
  promoCodeUsages PromoCodeUsage[]
  notifications Notification[]
  webhookEvents WebhookEventLog[] @relation("BookingWebhookEvents")
  shortNotice Boolean          @default(false)
  leadTimeDays Int?
  shortNoticeDepositCents Int?
  guestToken  String?
  claimedAt   DateTime?
  soilLevel   SoilLevel?
  cleaningPreferences Json?
  upholsteryDetails   Json?
  additionalInstructions String?
  supportTickets SupportTicket[]
}

enum BookingInvitationStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
}

model BookingInvitation {
  id          String                   @id @default(cuid())
  createdAt   DateTime                 @default(now())
  updatedAt   DateTime                 @updatedAt
  booking     Booking                  @relation(fields: [bookingId], references: [id])
  bookingId   String
  provider    ProviderProfile          @relation(fields: [providerId], references: [id])
  providerId  String
  status      BookingInvitationStatus  @default(PENDING)
  respondedAt DateTime?
  viewedAt    DateTime?
  metadata    Json?

  @@unique([bookingId, providerId])
}

model BookingAssignment {
  id         String          @id @default(cuid())
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt
  booking    Booking         @relation(fields: [bookingId], references: [id])
  bookingId  String
  provider   ProviderProfile @relation(fields: [providerId], references: [id])
  providerId String
  team       ProviderTeam?   @relation(fields: [teamId], references: [id])
  teamId     String?
  status     String          @default("pending")

  @@unique([bookingId, providerId])
}

model BookingAudit {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  booking   Booking  @relation(fields: [bookingId], references: [id])
  bookingId String
  actor     User?    @relation("UserBookingAudits", fields: [actorId], references: [id])
  actorId   String?
  action    String
  metadata  Json?
}

model Payment {
  id                String        @id @default(cuid())
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  booking           Booking       @relation(fields: [bookingId], references: [id])
  bookingId         String
  client            User          @relation("PaymentClient", fields: [clientId], references: [id])
  clientId          String
  amountCents       Int
  currency          String        @default("EUR")
  platformFeeCents  Int           @default(0)
  status            PaymentStatus
  method            PaymentMethod?
  provider          PaymentProvider @default(MOLLIE)
  externalReference String?
  externalCustomerId String?
  externalPaymentIntentId String?
  externalPaymentMethodId String?
  externalSetupIntentId String?
  externalMandateId   String?
  paymentMethodSnapshot Json?
  billingName       String?
  billingEmail      String?
  authorizedAt      DateTime?
  capturedAt        DateTime?
  releasedAt        DateTime?
  refundedAt        DateTime?
  cancellationReason String?
  occurredAt        DateTime

  distributions PaymentDistribution[]
  events        PaymentEvent[]
  invoice       Invoice?
  loyaltyTransactions LoyaltyTransaction[]
  disputes      Dispute[]
  webhookEvents WebhookEventLog[] @relation("PaymentWebhookEvents")

  @@unique([bookingId])
}

model PaymentMandate {
  id                   String         @id @default(cuid())
  createdAt            DateTime       @default(now())
  updatedAt            DateTime       @updatedAt
  client               User           @relation(fields: [clientId], references: [id])
  clientId             String
  provider             PaymentProvider @default(MOLLIE)
  externalMandateId    String         @unique
  externalPaymentMethodId String?
  method               PaymentMethod?
  status               String         @default("pending")
  reference            String?
  scheme               String?
  bankCountry          String?
  bankCode             String?
  last4                String?
  fingerprint          String?
  url                  String?
  usage                String?
  acceptedAt           DateTime?
  customerIp           String?
  customerUserAgent    String?
  lastSyncedAt         DateTime?
  revokedAt            DateTime?
  metadata             Json?
}

model PaymentDistribution {
  id              String   @id @default(cuid())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  payment         Payment  @relation(fields: [paymentId], references: [id])
  paymentId       String
  beneficiaryId   String
  beneficiaryType String
  amountCents     Int
  currency        String   @default("EUR")
  externalReference String?
  availableOn     DateTime?
  releasedAt      DateTime?
  payoutStatus    String   @default("pending")
  providerPayout  ProviderPayout? @relation(fields: [providerPayoutId], references: [id])
  providerPayoutId String?
}

model PaymentEvent {
  id        String          @id @default(cuid())
  createdAt DateTime        @default(now())
  payment   Payment?        @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  paymentId String?
  provider  PaymentProvider @default(MOLLIE)
  type      String
  payload   Json

  @@index([paymentId])
}

model WebhookEventLog {
  id                String                 @id @default(cuid())
  createdAt         DateTime               @default(now())
  updatedAt         DateTime               @updatedAt
  provider          String
  eventId           String?
  eventType         String?
  resourceId        String?
  status            WebhookDeliveryStatus  @default(RECEIVED)
  receivedAt        DateTime               @default(now())
  processedAt       DateTime?
  processingLatencyMs Int?
  requestUrl        String?
  signatureValid    Boolean?
  errorMessage      String?
  headers           Json?
  payload           Json?
  metadata          Json?
  bookingId         String?
  booking           Booking?               @relation("BookingWebhookEvents", fields: [bookingId], references: [id])
  paymentId         String?
  payment           Payment?               @relation("PaymentWebhookEvents", fields: [paymentId], references: [id])
  providerProfileId String?
  providerProfile   ProviderProfile?       @relation("ProviderWebhookEvents", fields: [providerProfileId], references: [id])
  userId            String?
  user              User?                  @relation("UserWebhookEvents", fields: [userId], references: [id])
  replayAttemptedAt DateTime?
  replayStatus      WebhookDeliveryStatus?
  replayError       String?

  @@index([provider, receivedAt])
  @@index([status, receivedAt])
  @@index([bookingId])
  @@index([paymentId])
  @@index([providerProfileId])
  @@index([userId])
}

model SystemApiKey {
  id              String             @id @default(cuid())
  createdAt       DateTime           @default(now())
  updatedAt       DateTime           @updatedAt
  name            String
  description     String?
  prefix          String             @unique
  tokenHash       String
  scopes          String[]           @default([])
  status          SystemApiKeyStatus @default(ACTIVE)
  rateLimitPerDay Int?
  lastUsedAt      DateTime?
  owner           User?              @relation("UserApiKeys", fields: [ownerId], references: [id], onDelete: SetNull)
  ownerId         String?
}

model DataImportJob {
  id             String           @id @default(cuid())
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  label          String
  entity         DataImportEntity
  format         DataJobFormat
  status         DataJobStatus    @default(PENDING)
  processedCount Int              @default(0)
  totalCount     Int?
  sourceFilename String?
  startedAt      DateTime?
  completedAt    DateTime?
  errorMessage   String?
  metadata       Json?
  createdBy      User?            @relation("DataImportJobCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
  createdById    String?
}

model DataExportJob {
  id            String        @id @default(cuid())
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  label         String
  type          DataExportType
  format        DataJobFormat
  status        DataJobStatus @default(PENDING)
  recordCount   Int?
  fileUrl       String?
  expiresAt     DateTime?
  completedAt   DateTime?
  errorMessage  String?
  parameters    Json?
  requestedBy   User?         @relation("DataExportJobRequestedBy", fields: [requestedById], references: [id], onDelete: SetNull)
  requestedById String?
}

model PromoCode {
  id                    String         @id @default(cuid())
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt
  code                  String         @unique
  type                  PromoCodeType
  fixedAmountCents      Int?
  percentage            Int?
  description           String?
  startsAt              DateTime?
  endsAt                DateTime?
  maxTotalUsages        Int?
  maxUsagesPerUser      Int?
  minBookingTotalCents  Int?
  applicableServices    String[]       @default([])
  applicablePostalCodes String[]       @default([])
  isActive              Boolean        @default(true)
  createdBy             User?          @relation("PromoCodeCreator", fields: [createdById], references: [id])
  createdById           String?
  usageCount            Int            @default(0)
  lastUsedAt            DateTime?
  metadata              Json?

  usages                PromoCodeUsage[]
  bookings              Booking[]
}

model PromoCodeUsage {
  id                   String    @id @default(cuid())
  createdAt            DateTime  @default(now())
  promoCode            PromoCode @relation(fields: [promoCodeId], references: [id])
  promoCodeId          String
  booking              Booking?  @relation(fields: [bookingId], references: [id])
  bookingId            String?
  client               User?     @relation("PromoCodeUsageClient", fields: [clientId], references: [id])
  clientId             String?
  amountDiscountCents  Int
  currency             String    @default("EUR")
  status               String?
  metadata             Json?

  @@index([promoCodeId])
  @@index([bookingId])
  @@index([clientId])
  @@unique([promoCodeId, bookingId])
}

model Dispute {
  id               String        @id @default(cuid())
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  booking          Booking       @relation(fields: [bookingId], references: [id])
  bookingId        String
  payment          Payment?      @relation(fields: [paymentId], references: [id])
  paymentId        String?
  status           DisputeStatus @default(OPEN)
  reason           String
  description      String?
  openedBy         User?         @relation("DisputeOpenedBy", fields: [openedById], references: [id])
  openedById       String?
  assignedTo       User?         @relation("DisputeAssigned", fields: [assignedToId], references: [id])
  assignedToId     String?
  resolution       String?
  refundAmountCents Int?
  refundCurrency   String?       @default("EUR")
  refundProcessedAt DateTime?
  resolvedAt       DateTime?
  adminNotes       String?
  messages         DisputeMessage[]

  @@index([bookingId])
  @@index([paymentId])
  @@index([status])
}

model DisputeMessage {
  id        String                  @id @default(cuid())
  createdAt DateTime                @default(now())
  dispute   Dispute                 @relation(fields: [disputeId], references: [id], onDelete: Cascade)
  disputeId String
  author    User?                   @relation("UserDisputeMessages", fields: [authorId], references: [id])
  authorId  String?
  role      DisputeParticipantRole
  message   String
  attachments Json?

  @@index([disputeId])
}

model Invoice {
  id                  String     @id @default(cuid())
  createdAt           DateTime   @default(now())
  updatedAt           DateTime   @updatedAt
  invoiceNumber       String     @unique
  issuedAt            DateTime
  status              String     @default("issued")
  currency            String     @default("EUR")
  subtotalCents       Int
  ecoSurchargeCents   Int        @default(0)
  loyaltyCreditsCents Int        @default(0)
  extrasCents         Int        @default(0)
  taxCents            Int        @default(0)
  totalCents          Int
  booking             Booking    @relation(fields: [bookingId], references: [id])
  bookingId           String
  payment             Payment?   @relation(fields: [paymentId], references: [id])
  paymentId           String?    @unique
  document            Document?  @relation(fields: [documentId], references: [id])
  documentId          String?    @unique

  @@index([bookingId])
}

model PricingRule {
  id              String              @id @default(cuid())
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  code            String              @unique
  type            PricingRuleType
  audience        PricingRuleAudience @default(GENERAL)
  description     String?
  amountCents     Int?
  percentageBps   Int?
  multiplier      Float?
  minSquareMeters Int?
  maxSquareMeters Int?
  isActive        Boolean             @default(true)
  priority        Int                 @default(100)
}

model LoyaltyBalance {
  id               String               @id @default(cuid())
  createdAt        DateTime             @default(now())
  updatedAt        DateTime             @updatedAt
  client           User                 @relation(fields: [clientId], references: [id])
  clientId         String               @unique
  points           Int                  @default(0)
  lifetimeEarned   Int                  @default(0)
  lifetimeRedeemed Int                  @default(0)
  lastEarnedAt     DateTime?
  lastRedeemedAt   DateTime?
  transactions     LoyaltyTransaction[]
}

model LoyaltyTransaction {
  id         String                 @id @default(cuid())
  createdAt  DateTime               @default(now())
  balance    LoyaltyBalance         @relation(fields: [balanceId], references: [id], onDelete: Cascade)
  balanceId  String
  type       LoyaltyTransactionType
  points     Int
  booking    Booking?               @relation(fields: [bookingId], references: [id])
  bookingId  String?
  payment    Payment?               @relation(fields: [paymentId], references: [id])
  paymentId  String?
  metadata   Json?

  @@index([balanceId])
  @@index([bookingId])
  @@index([paymentId])
}

model EmailQueue {
  id          String            @id @default(cuid())
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  to          String
  template    String
  payload     Json
  status      EmailQueueStatus  @default(PENDING)
  scheduledAt DateTime?
  sentAt      DateTime?
  error       String?

  @@index([status, scheduledAt])
}

model Review {
  id               String          @id @default(cuid())
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  booking          Booking         @relation(fields: [bookingId], references: [id])
  bookingId        String
  author           User            @relation("ReviewAuthor", fields: [authorId], references: [id])
  authorId         String
  targetProvider   ProviderProfile @relation("ProviderReviews", fields: [targetProviderId], references: [id])
  targetProviderId String
  score            Int
  comment          String?
  ecoCompliance    Boolean
  status           ReviewStatus    @default(PUBLISHED)
  moderationNotes  String?
  moderatedBy      User?           @relation("ReviewModeratedBy", fields: [moderatedById], references: [id])
  moderatedById    String?
  moderatedAt      DateTime?
}

model RefreshToken {
  id        String    @id @default(cuid())
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  user      User      @relation(fields: [userId], references: [id])
  userId    String
  tokenHash String
  expiresAt DateTime
  revokedAt DateTime?
  userAgent String?
  ipAddress String?

  @@index([userId])
  @@index([expiresAt])
}

model ProviderServiceZone {
  id          String          @id @default(cuid())
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  provider    ProviderProfile @relation(fields: [providerId], references: [id])
  providerId  String
  name        String
  postalCode  String?
  city        String?
  district    String?
  countryCode String?
  latitude    Float?
  longitude   Float?
  radiusKm    Float?          @default(5)
}

model ProviderAvailabilitySlot {
  id          String          @id @default(cuid())
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  provider    ProviderProfile @relation(fields: [providerId], references: [id])
  providerId  String
  weekday     Int
  startMinutes Int
  endMinutes  Int
  timezone    String          @default("Europe/Berlin")
  isActive    Boolean         @default(true)

  @@index([providerId, weekday])
}

model ProviderTimeOff {
  id         String          @id @default(cuid())
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt
  provider   ProviderProfile @relation(fields: [providerId], references: [id])
  providerId String
  startAt    DateTime
  endAt      DateTime
  reason     String?

  @@index([providerId, startAt])
}

model ProviderTeam {
  id               String               @id @default(cuid())
  createdAt        DateTime             @default(now())
  updatedAt        DateTime             @updatedAt
  owner            ProviderProfile      @relation("ProviderTeamOwner", fields: [ownerId], references: [id])
  ownerId          String
  name             String
  description      String?
  serviceCategories String[]            @default([])
  preferredSize    Int?
  isActive         Boolean              @default(true)
  notes            String?
  defaultDailyCapacity Int?
  timezone         String?

  members          ProviderTeamMember[]
  preferredBookings Booking[]           @relation("BookingPreferredTeam")
  assignedBookings  Booking[]           @relation("BookingAssignedTeam")
  assignments       BookingAssignment[]
  fallbackBookings  Booking[]           @relation("BookingFallbackTeam")
  plans             TeamPlan[]
  bookingLocks      BookingTeamLock[]
}

model ProviderTeamMember {
  id         String          @id @default(cuid())
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt
  team       ProviderTeam    @relation(fields: [teamId], references: [id])
  teamId     String
  provider   ProviderProfile @relation(fields: [providerId], references: [id])
  providerId String
  role       String?
  isLead     Boolean         @default(false)
  orderIndex Int             @default(0)

  @@unique([teamId, providerId])
}

enum BookingTeamLockStatus {
  HELD
  CONFIRMED
  RELEASED
}

model TeamPlan {
  id              String      @id @default(cuid())
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  providerTeam    ProviderTeam @relation(fields: [providerTeamId], references: [id], onDelete: Cascade)
  providerTeamId  String
  date            DateTime
  capacitySlots   Int
  capacityBooked  Int         @default(0)
  notes           String?

  slots           TeamPlanSlot[]

  @@unique([providerTeamId, date])
}

model TeamPlanSlot {
  id         String    @id @default(cuid())
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  teamPlan   TeamPlan  @relation(fields: [teamPlanId], references: [id], onDelete: Cascade)
  teamPlanId String
  startAt    DateTime
  endAt      DateTime
  capacity   Int
  booked     Int       @default(0)

  locks      BookingTeamLock[]
}

model BookingTeamLock {
  id             String                @id @default(cuid())
  createdAt      DateTime              @default(now())
  updatedAt      DateTime              @updatedAt
  booking        Booking               @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  bookingId      String
  providerTeam   ProviderTeam?         @relation(fields: [providerTeamId], references: [id], onDelete: Cascade)
  providerTeamId String?
  provider       ProviderProfile?      @relation(fields: [providerId], references: [id], onDelete: Cascade)
  providerId     String?
  teamPlanSlot   TeamPlanSlot?         @relation(fields: [teamPlanSlotId], references: [id], onDelete: Cascade)
  teamPlanSlotId String?
  lockedCount    Int                   @default(1)
  status         BookingTeamLockStatus @default(HELD)
  expiresAt      DateTime

  @@unique([bookingId, providerId])
}

model MatchingConfig {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  weightsJson   Json?
  distanceMaxKm Float    @default(20)
  teamBonusJson Json?
}

model PostalFollowUpRequest {
  id                   String   @id @default(cuid())
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  email                String
  postalCode           String
  normalizedPostalCode String
  normalizedCity       String?
  marketingConsent     Boolean  @default(false)

  @@index([normalizedPostalCode])
  @@index([email])
  @@unique([email, normalizedPostalCode])
}

model MarketingLandingPage {
  id              String                 @id @default(cuid())
  createdAt       DateTime               @default(now())
  updatedAt       DateTime               @updatedAt
  title           String
  slug            String                 @unique
  path            String                 @unique
  status          MarketingLandingStatus @default(DRAFT)
  impressions     Int                    @default(0)
  conversions     Int                    @default(0)
  leads           Int                    @default(0)
  bounceRate      Float?
  seoTitle        String?
  seoDescription  String?
  heroTitle       String?
  heroDescription String?
}

model MarketingSetting {
  id                           Int       @id @default(1)
  createdAt                    DateTime  @default(now())
  updatedAt                    DateTime  @updatedAt
  promoCodesEnabled            Boolean   @default(true)
  referralEnabled              Boolean   @default(false)
  marketingNotificationsEnabled Boolean  @default(true)
  maxPromoCodesPerClient       Int       @default(3)
  stackingRules                String?   @db.Text
  restrictedZones              String?   @db.Text
  updatedById                  String?
  updatedBy                    User?     @relation("MarketingSettingUpdatedBy", fields: [updatedById], references: [id])
  logs                         MarketingSettingLog[]
}

model MarketingSettingLog {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  label       String
  previousValue String?
  newValue    String?
  setting     MarketingSetting @relation(fields: [settingId], references: [id])
  settingId   Int
  user        User?    @relation(fields: [userId], references: [id])
  userId      String?
}
